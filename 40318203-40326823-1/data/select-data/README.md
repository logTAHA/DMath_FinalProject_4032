# 🐦 TwiBot‑22 نمونه گیری از دیتاست

‏این پروژه مربوط به انتخاب یک زیرمجموعه کوچک و معنادار از دیتاست **TwiBot‑22** است.

---

## 📌 معرفی دیتاست اصلی  

‏دیتاست **TwiBot‑22** توسط یک تیم تحقیقاتی بین‌المللی به سرپرستی **Shangbin Feng** تهیه شده و شامل سه بخش اصلی است:  

- **اطلاعات کاربران (users)**  
- **توییت‌ها (tweets)**  
- **روابط بین کاربران** مثل فالو، لایک و …  

[لینک گیت‌هاب پروژه TwiBot‑22](https://github.com/LuoUndergradXJTU/TwiBot-22)  
[لینک گوگل درایو دیتاست](https://drive.google.com/drive/folders/1YwiOUwtl8pCd2GD97Q_WEzwEUtSPoxFs?usp=sharing)  

---

## 🎯 هدف پروژه  

‏از آنجا که دیتاست اصلی بسیار بزرگ است، نیاز داشتیم یک **نمونه کوچک‌تر ولی معنادارتر** از آن انتخاب کنیم تا برای تحلیل گراف و آزمایش‌ها مناسب باشد.  

---

## 🛠 روند آماده‌سازی دیتاست  

### ۱. انتخاب کاربران اولیه  

- از فایل `following.csv` (روابط فالو) استفاده شد.  
- مجموعه‌ای از کاربران انتخاب و در فایل `selected-users.txt` ذخیره شدند.  

### ۲. استخراج روابط فیلترشده  

- از بین تمام روابط موجود، فقط آن‌هایی نگه داشته شدند که **هر دو سر رابطه (source و target)** در `selected-users.txt` حضور داشتند.  

### ۳. استخراج اطلاعات کاربران منتخب  

- اطلاعات کاربران انتخاب‌شده از فایل اصلی `user.json` خوانده شد.  
- فقط ستون‌های مهم مانند:  
  `id`, `username`, `name`, `description`, `location`, `verified`, `protected`, `created_at`  
  نگه‌داری و در فایل `selected-users-detail.json` ذخیره شدند.  

---

## ⚡ چالش در انتخاب کاربران  

‏اگر ۱۰۰ کاربر به صورت تصادفی انتخاب می‌کردیم، احتمال اینکه بین آن‌ها روابط معناداری وجود داشته باشد کم بود و نمونه نهایی گسسته و بی‌ارتباط می‌شد.  

### روش اول (و مشکل آن)  

- ابتدا یک نود با درجه بالا به صورت تصادفی انتخاب می‌شد.  
- سپس با الگوریتم **DFS یا BFS** تا رسیدن به ۱۰۰ نود ادامه می‌دادیم.  
- **مشکل:** این روش تنوع گراف را کاهش می‌داد و کاربران به شکل زنجیره‌ای به هم متصل می‌شدند.  

---

## ✅ راه‌حل نهایی برای انتخاب کاربران  

### مرحله ۱: ساخت گراف بدون جهت  

- فایل `following.csv` به یک گراف **بدون جهت** تبدیل میشود.  
- اگر`a → b` آنگاه `b` به همسایه‌های `a` و `a` به همسایه‌های `b` اضافه میشود.
- این گراف در متغیر `relations` ذخیره میشود.  

### مرحله ۲: انتخاب اولیه سه نود  

1. یک نود تصادفی انتخاب شد → **node1**  
2. از همسایه‌های `node1` یک نود دیگر انتخاب شد → **node2**  
3. از همسایه‌های `node2` (به جز `node1`) یک نود سوم انتخاب شد → **node3**  

این سه نود در مجموعه `selected` ذخیره شدند.  

### مرحله ۳: گسترش مجموعه `selected`  

تا زمانی که اندازه `selected` کمتر از ۵۰ بود:  
- مجموعه‌ای خالی به نام `candidate` ساخته شد.  
- برای هر عضو `selected`، همسایه‌هایش به `candidate` اضافه شدند.  
- اعضایی که قبلاً در `selected` بودند از `candidate` حذف شدند تا دوباره انتخاب نشوند.  

اگر `candidate` خالی نبود:  
- با تابع `best_node` بهترین نود انتخاب شد.  
  - این نود کسی بود که **بیشترین اشتراک روابط با کاربران انتخاب‌شده** را داشت.  

اگر `candidate` خالی بود:  
- از بین مجموعه `remaining = all_nodes - selected` بهترین نود انتخاب شد.  

### مرحله ۴: دو بار اجرای فرآیند برای تنوع گراف  

- این فرآیند دوبار اجرا شد تا دو زیرگراف نسبتاً مستقل انتخاب شوند.  
- در هر بار ۵۰ کاربر انتخاب شدند.  
- در نهایت برای نظم بهتر گراف و جلوگیری از شلوغی بیش از حد، ۴ کاربر با تعداد روابط بالا و بی اثر در کلیت گراف حذف شدند.  

---

## 📊 نتیجه نهایی  

- در نهایت **۹۶ کاربر** در فایل `data/users.txt` ذخیره شدند.  
- مجموعاً **۴۱۴ رابطه فالو** بین این کاربران در فایل `data/following.csv` ثبت شد.  
- اطلاعات تکمیلی این کاربران (نام، نام کاربری، توضیحات، مکان، و …) در فایل `data/users-detail.json` ذخیره شد.  
